<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/shell.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/os-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">vtmm</a><ul><li><a href="#h2-1">研究问题</a></li></ul><ul><li><a href="#h2-2">局限性分析</a><ul><li><a href="#h3-3">页面追踪</a></li></ul><ul><li><a href="#h3-4">页面分类</a></li></ul><ul><li><a href="#h3-5">页面迁移</a></li></ul><ul><li><a href="#h3-6">动态内存分区</a></li></ul></li></ul><ul><li><a href="#h2-7">解决方案</a></li></ul><ul><li><a href="#h2-8">实验</a></li></ul><ul><li><a href="#h2-9">个人思考</a></li></ul><ul><li><a href="#h2-10">摘抄</a></li></ul><ul><li><a href="#h2-11">PML</a><ul><li><a href="#h3-12">PML 的背景和需求</a></li></ul><ul><li><a href="#h3-13">PML 的工作原理</a></li></ul><ul><li><a href="#h3-14">PML 的优点</a></li></ul></li></ul><ul><li><a href="#h2-15">vTMM 的设计优势和对比缺点</a><ul><li><a href="#h4-16">设计优势</a></li></ul><ul><li><a href="#h4-17">对比缺点</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">vtmm</h1><ul><li>题目: vTMM: Tiered Memory Management for Virtual Machines</li></ul><ul><li>会议: EuroSys&#x27;23</li></ul><ul><li>视频: -</li></ul><ul><li>代码: -</li></ul><h2 id="h2-1">研究问题</h2><blockquote><p>论文试图解决的具体问题是什么?该问题的核心挑战是什么?</p></blockquote><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><p><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div> 分层内存管理在虚拟化的挑战</p></blockquote><p>快内存(FMem)和慢内存(SMem)组成了分层内存系统.研究人员专注于将活动(热)页面放入 FMem 中,将非活动(冷)页面放入 SMem 中,以获得最佳性能.经典的管理方法通过页面跟踪、分类和迁移来实现目标.按照这种设计,许多先进的技术被开发出来,例如<a href="../../md-docs\thermostat" target="_self">Thermostat</a> 、<a href="../../md-docs\hemem" target="_self">HeMem</a> 、<a href="../../md-docs\nimble" target="_self">Nimble</a> 、<a href="../../md-docs\HeteroOS" target="_self">HeteroOS</a> 、<a href="../../md-docs\raminate" target="_self">RAMinate</a> 等.不幸的是,<b>它们都不能提供有效的管理虚拟化分层内存管理</b>, 虚拟化的新挑战主要包括:</p><ul><li><b>性能隔离</b>:<p>多虚拟机(VM)并行运行会产生强烈的内存竞争,例如使用Intel Optane内存模式(MM)作为直接映射缓存的情况下,多虚拟机并行运行会导致DRAM缓存污染,DRAM缓存未命中次数增加2到4倍​​.</p></li></ul><ul><li><b>上下文切换开销</b>:<p>虚拟化引入了VM上下文,因此需要尽量减少昂贵的VM陷阱(VMTraps,例如在客户机和宿主机之间的上下文切换).例如,HeMem采用的基于写保护的页面迁移方法会因为写入异常处理而引发大量VMTraps,导致性能下降​​.</p></li></ul><ul><li><b>多样化的内存访问模式</b>:<p>在云环境中,不同的应用在多个虚拟机中并行运行,表现出更多样的内存访问模式.这对多虚拟机的页面放置策略提出了新的挑战,要求系统能够灵活适应不同的内存访问模式​​.</p></li></ul><ul><li><b>内存超分配</b>:<p>在分层内存系统中,虚拟机内存超分配(VM memory overcommit)需要处理不同于传统DRAM系统的设计空间.虽然大容量的慢速内存(SMem)能够保证充足的虚拟机内存容量,但快速内存(FMem)仍然是稀缺资源.理想的管理应在多个虚拟机之间动态平衡快速内存的使用,以实现更好的整体性能​​.</p></li></ul><h2 id="h2-2">局限性分析</h2><blockquote><p>现有研究的主要局限或缺点是什么?</p></blockquote><p>本文对比了同其他分层内存管理方案在页面跟踪、分类和迁移的区别, 如下表所示</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240530155925.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240530155925.png" alt="20240530155925"></a></p><h3 id="h3-3">页面追踪</h3><p>页表(PT)扫描通过定期检查和清除访问/脏位来跟踪内存访问.特别是,针对虚拟化系统</p><ul><li>虚拟机的内存占用很大,导致每次扫描的页表都很大,无论应用程序的工作集大小如何在虚拟机上运行.由于 EPT 扫描器不知道访问了哪些页面,因此它必须扫描整个 VM 映射以检查页面的 A/D 位,这会导致扫描时间较长<blockquote><p>对于一个分配了 60GB 内存的虚拟机, 即使可能 guest OS 仅使用到了一点内存, 但是 host OS 仍然需要完整的扫描 60GB 的地址空间</p></blockquote></li></ul><ul><li>设置 A/D 位和刷新 TLB 会显着减慢内存访问速度,尤其是在具有昂贵的 2D 地址转换的虚拟化中</li></ul><ul><li>RAMinate 会扫描 EPT,称为 EPT 扫描仪.然而,如果没有适当的优化,PT 扫描可能会因为额外的 MMU 压力而导致不可接受的开销</li></ul><ul><li>DAMON 是一个Linux内核内存数据访问监控框架,它还检查访问的位以监控页面.它采用区域采样来减少开销,但无法确定不同应用的区域数量来控制最佳精度和开销.</li></ul><ul><li>thermostat 通过 BadgerTrap 监视页面错误来跟踪页面.然而,它仅随机分析总内存的 0.5%,如果分析所有页面,则会导致速度降低数倍</li></ul><ul><li>autotiering 通过 NUMA 页面错误监控来跟踪多层内存的内存访问.</li></ul><ul><li>HeMem 通过 Intel PEBS 跟踪页面,这对虚拟化不友好.由于虚拟化的安全隔离,Hypervisor无法使用PEBS跟踪VM内存访问. PEBS 设施无法在主机端存储访客线性地址,因为访客无法写入主机的 PEBS 缓冲区. 另外,PEBS开销对于常规页面在线追踪来说是不可接受的</li></ul><blockquote><p>PEBS 不能在虚拟化中使用的原因具体见 <a href="../../md-docs\hugescope" target="_self">hugescope</a></p></blockquote><h3 id="h3-4">页面分类</h3><p>我们根据访问模式对页面进行分类,以确定要放置在 FMem 中的热集.现有设计通过使用LRU算法[raminate, heteroos, autotiering, nimble]或固定阈值方法[thermostat, hemem]来区分热页和冷页.</p><ul><li>LRU 用于交换 Linux 内存子系统中的不活动(冷)页面.然而,它<b>不适合跟踪热点页面,因为它关注的是页面访问的顺序而不是访问频率</b>.我们将通过第 4.8 节中的实验来证明这一点.</li></ul><ul><li>我们观察到使用固定阈值无法适应不同的内存访问模式(§4.5).对于匿名页面分类, autotiering 使用访问计数排名,这与我们的设计类似.然而,它对读和写的处理是统一的.我们应该根据不同的性能特征来权衡读取和写入,尤其是带宽</li></ul><h3 id="h3-5">页面迁移</h3><p>它是页面放置策略的执行者. Raw Linux ,Nimble 通过并行和页面交换提供高 THP 迁移吞吐量. Autotiering 采用与 Nimble 相同的设计.由于在复制数据之前取消映射页面,两者都会在迁移过程中产生长时间的页面访问暂停. HeMem 使用页面写保护来减少迁移期间的页面访问暂停,但<b>在虚拟化中,写保护会触发昂贵的 VMTrap</b>,例如影子分页同步</p><h3 id="h3-6">动态内存分区</h3><p>对于多VM分层内存管理,我们应该考虑内存分区来提高性能和利用率.尽管HeteroOS讨论了扩展内存过量使用的气球机制,但它没有实现动态分区.此外,慢速气球不再适合分层内存管理,特别是调整常规页面[22],并且需要定制来宾操作系统以区分FMem和SMem.</p><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><p><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div> 分层内存管理中的动态内存分区(Dynamic Memory Partitioning)是一种内存管理技术,用于在多层次内存架构中高效地分配和管理内存资源.该技术通过动态调整内存分区的大小和位置,以适应不同工作负载的需求,提高系统整体性能和资源利用率.</p></blockquote><hr><p>总的来说,现有的工作都不是专门为虚拟化设计的</p><ol start="1"><li>它们不支持虚拟化,或者在内存跟踪和页面迁移期间触发大量开销;</li></ol><ol start="2"><li>他们缺乏一种更具适应性的策略来区分不同虚拟机应用程序的热页和冷页.</li></ol><ol start="3"><li>它们不执行有效的内存动态分区.相比之下,vTMM 专为 VM 分层内存管理而设计,并利用虚拟化功能来优化页面操作并减少管理开销.</li></ol><p>vTMM 通过 PT 扫描来跟踪页面,但利用多级队列来减少开销.它根据页面&quot;温度&quot;排序对热/冷页面进行分类,并使用 PML 迁移页面,以最大限度地减少访问暂停和虚拟化性能损失.最后,vTMM 通过利用页面迁移和重新映射在虚拟机之间动态分区小型 FMem,以提高多个虚拟机共同运行时的利用率和整体性能.</p><h2 id="h2-7">解决方案</h2><blockquote><p>动机</p></blockquote><p>Intel 的 Page-Modification Logging (PML) 是一种硬件辅助的内存管理技术,用于高效跟踪虚拟机中被修改的内存页.PML 主要设计用于虚拟化环境,特别是为了优化虚拟机的迁移和快照操作.</p><p>在没有PML前,VMM要监控虚拟机中物理页面的修改,需要将EPT的页面结构设置为not-present或者read-only,这样会触发许多EPT violations,开销非常大.</p><p>PML建立在CPU对EPT中的accessed与dirty标志位支持上. 当启用PML时,对EPT中设置了dirty标志位的写操作都会产生一条in-memory记录,报告写操作的虚拟机物理地址,当记录写满时,触发一次VM Exit,然后VMM就可以监控被修改的页面.</p><blockquote style="border-left-color: #1a7f37; background-color: #e5f6ea;"><p><div style="color: #1a7f37;"><img class="icon-tip" loading="lazy" src="../../../img/tip.svg" alt="[!TIP]"> TIP </div></p><p>判断 CPU 是否支持 PML</p><pre class="language-shell"><code><span class="Token Program ID">cat</span><span class="Token SPACE"> </span><span class="Token PATH">/proc/cpuinfo</span><span class="Token SPACE"> </span><span class="Token PIPE">|</span><span class="Token SPACE"> </span><span class="Token Program ID">grep</span><span class="Token SPACE"> </span><span class="Token OPTION">-i</span><span class="Token SPACE"> </span><span class="Token ID">pml</span></code></pre><p>开启 PML 需要修改 GRUB 配置文件</p><pre class="language-shell"><code><span class="Token Variant Program ID">GRUB_CMDLINE_LINUX_DEFAULT</span><span class="Token ASSIGN">=</span><span class="Token String STRING">&quot;quiet splash pml=enable&quot;</span></code></pre></blockquote><h2 id="h2-8">实验</h2><blockquote><p>实验是如何设计的? 结果如何证明了论文方法的有效性?是否有对比实验?</p></blockquote><h2 id="h2-9">个人思考</h2><blockquote><p>阅读论文时,有没有引发你思考出新的问题或有待解决的挑战?</p></blockquote><h2 id="h2-10">摘抄</h2><h2 id="h2-11">PML</h2><h3 id="h3-12">PML 的背景和需求</h3><p>在虚拟化环境中,当需要将一个运行中的虚拟机从一个物理主机迁移到另一个主机,或者创建虚拟机的快照时,需要跟踪虚拟机中哪些内存页被修改过.这些操作通常涉及到大量的内存页,需要频繁地检查和记录页的修改状态.如果依赖软件层面的处理,这会产生很大的性能开销.</p><h3 id="h3-13">PML 的工作原理</h3><p>.其工作原理如下:</p><ol start="1"><li><b>硬件支持的日志记录</b>:<ul><li>PML 引入了一种新的日志结构,即 PML 日志.</li></ul><ul><li>当虚拟机中的某个内存页被修改时,硬件会自动将该页的地址记录到 PML 日志中.</li></ul></li></ol><ol start="2"><li><b>减少开销</b>:<ul><li>通过硬件直接记录被修改的页地址,避免了频繁的虚拟化管理程序(如 Hypervisor)干预,从而减少了性能开销.</li></ul></li></ol><ol start="3"><li><b>日志处理</b>:<ul><li>PML 日志是一个固定大小的环形缓冲区.当日志被填满时,CPU 会产生一个 VM 退出(VM-exit)事件,通知虚拟化管理程序处理日志.</li></ul><ul><li>虚拟化管理程序读取并清空日志后,PML 日志可以继续使用.</li></ul></li></ol><ol start="4"><li><b>增强迁移和快照性能</b>:<ul><li>在虚拟机迁移过程中,PML 可以高效地确定哪些内存页被修改过,只有这些页需要复制到目标主机,从而减少了迁移时间.</li></ul><ul><li>在快照操作中,PML 可以记录自上次快照以来被修改的页,提高快照的增量备份效率.</li></ul></li></ol><h3 id="h3-14">PML 的优点</h3><ol start="1"><li><b>性能提升</b>:通过硬件辅助的日志记录,减少了虚拟化管理程序频繁检查页修改状态的开销,提高了虚拟机迁移和快照操作的性能.</li></ol><ol start="2"><li><b>高效内存管理</b>:PML 能够准确跟踪被修改的内存页,确保在迁移和快照过程中只处理必要的数据,减少了不必要的数据传输.</li></ol><ol start="3"><li><b>简化开发</b>:虚拟化管理程序可以依赖硬件提供的日志记录功能,简化了内存页修改跟踪的实现.</li></ol><h2 id="h2-15">vTMM 的设计优势和对比缺点</h2><p>根据论文第 2.2 节的总结,vTMM (Tiered Memory Management) 与其他分层内存管理方法相比,主要有以下设计优势和对比缺点:</p><h4 id="h4-16">设计优势</h4><ol start="1"><li><b>基于 PML 的 GPT 扫描器</b>:<ul><li>vTMM 使用基于 PML (Page Modification Logging) 的 GPT (Guest Page Table) 扫描器,仅追踪活跃进程的页面,设计了多级队列以减少页面追踪的开销.</li></ul></li></ol><ol start="2"><li><b>冷热页面分类</b>:<ul><li>采用基于桶排序的冷热页面分类器,能够适应各种内存访问模式,准确区分出热点页面和冷门页面 .</li></ul></li></ol><ol start="3"><li><b>并行页面迁移</b>:<ul><li>vTMM 在最小访问暂停的情况下并行迁移页面,并巧妙地处理脏页面,通过利用 PML 来减少迁移过程中对 VM 的影响 .</li></ul></li></ol><ol start="4"><li><b>动态内存池</b>:<ul><li>设计了一个内存池,动态地在虚拟机之间分配内存,以提高多虚拟机同时运行时的性能.通过这种方式,vTMM 能够有效地管理和优化内存资源的使用 .</li></ul></li></ol><ol start="5"><li><b>透明大页支持</b>:<ul><li>扩展了 vTMM 以支持透明大页(THP),并在 DRAM+NVM 系统和 CXL-Memory 系统上进行了广泛的评估和对比 .</li></ul></li></ol><h4 id="h4-17">对比缺点</h4><ol start="1"><li><b>页面追踪</b>:<ul><li>其他方法如 PT 扫描、页面错误监控和 PEBS(Processor Event-Based Sampling)在虚拟化环境中的应用存在困难.PT 扫描方法会引起较大的开销,而页面错误监控在细粒度页面管理时会导致巨大开销  .</li></ul></li></ol><ol start="2"><li><b>分类方法</b>:<ul><li>一些现有的方法无法灵活适应不同的内存访问模式,而 vTMM 的桶排序方法能更好地适应各种模式,精确分类页面 .</li></ul></li></ol><ol start="3"><li><b>页面迁移策略</b>:<ul><li>现有方法在处理页面迁移时可能导致较长的访问暂停,而 vTMM 能通过并行迁移和有效处理脏页面来减少对 VM 的影响 .</li></ul></li></ol><ol start="4"><li><b>内存管理灵活性</b>:<ul><li>vTMM 通过动态内存池在虚拟机之间重新分配内存,比一些静态分配的方法在资源利用率和性能上有明显优势 .</li></ul></li></ol><p>综上所述,vTMM 通过创新性的页面追踪和分类方法、并行页面迁移策略,以及灵活的内存池管理,克服了现有分层内存管理方法的一些不足,在提升虚拟机性能和资源利用效率方面具有明显的优势.</p><hr><p>在我们的工作中,英特尔 PML 机制被使用了两次:捕获 GPT 的 A/D 位设置(第 3.2 节)并优化页面迁移的脏处理,如虚拟机实时迁移(第 3.4 节). Intel PML 是一种硬件辅助虚拟化技术,可跟踪 VM 实时迁移的脏页 [3, 11].在 PML 出现之前,虚拟机管理程序对所有 VM 页面进行写保护,修改迁移的页面会触发昂贵的 VMTrap 来跟踪脏页面.在来宾物理访问之前,处理器可能会确定它首先需要为其 EPT 条目 (EPTE) 设置已访问或脏位 [26].如果启用了 PML,则当脏位被设置时,MMU 会将所访问的常规/大页面的客户物理地址 (GPA) 记录到 PML 缓冲区.每个 VCPU 都有一个单独的 PML 缓冲区,其中包含 512 个条目(即 4KB 页).页面修改日志已满事件将触发虚拟机退出[26].然后,管理程序将刷新 PML 缓冲区以更新脏页位图 [6].特别是,每当 VM 由于某种原因退出时,虚拟机管理程序都会刷新 PML 缓冲区. hypervisor需要首先清除EPT中的脏位,以确保写入页面时会设置其脏位.此外,虚拟机管理程序还需要刷新相应的 TLB(包括常规 TLB 和 ETLB [26])以强制执行 2D 页遍历.总而言之,Intel PML 可以跟踪硬件中虚拟机的脏页,而不会触发昂贵的 VMTrap</p><p>为了减少设置A/D位和刷新TLB的开销(挑战(2)),我们设计了一种多级队列算法.频繁设置 A/D 位和刷新热页的 TLB 是主要开销.根据局部性[23, 37],已经访问过的页面将来很可能会被访问​​多次.基于出于这种动机,多级队列放松了根据访问历史记录对热点页面的监控.在监控窗口中,vTMM通过多级队列过滤每个页面,决定是否清除页面的A/D位.多级队列以监控窗口为单位处理时间事件.开始时,所有页都处于级别 0.此时需要清除级别 0 的页的 A/D 位.对于级别 x (x &gt; 0),我们定义请勿打扰 (DND) 时间为 2x−1,这意味着级别 x 中页面的 A/D 位只有在 2 x−1 间隔后才会被清除(即监控窗口)稍后.直观上,该公式利用了内存访问局部性.活动页面越多,免打扰时间应该越长.请勿打扰时间内的页面被视为连续访问.当寻呼的 DND 时间结束时,应在该时间间隔内清除其 A/D 位.在下一个时间间隔,如果该页再次被设置 A/D 位,则表明该页处于活动状态(热).因此,我们升级了它的等级,使其免打扰时间更长.否则,说明该页面没有被持续访问,因此我们降低其级别以减少其免打扰时间.如果某页的电平下降到 0,我们就清除该页的 A/D 位.热点页免打扰时间较长,队列过滤掉其A/D位设置,并估算访问计数,而低级队列中的冷页免打扰时间较短,避免被误过滤掉而漏计数.</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/tpp" >tpp</a></li></ul><ul><li><a href="../../md-docs/vtmm" >vtmm</a></li></ul><ul><li><a href="../../md-docs/hugescope" >hugescope</a></li></ul><ul><li><a href="../../md-docs/memtis" >memtis</a></li></ul><ul><li><a href="../../md-docs/hugegpt" >hugegpt</a></li></ul><ul><li><a href="../../md-docs/hemem" >hemem</a></li></ul><ul><li><a href="../../md-docs/nimble" >nimble</a></li></ul><ul><li><a href="../../md-docs/mitosis" >mitosis</a></li></ul><ul><li><a href="../../md-docs/thermostat" >thermostat</a></li></ul><ul><li><a href="../../md-docs/telescope" >telescope</a></li></ul><ul><li><a href="../../md-docs/mtm" >mtm</a></li></ul><ul><li><a href="../../md-docs/nomad" >nomad</a></li></ul><ul><li><a href="../../md-docs/autotiering" >autotiering</a></li></ul><ul><li><a href="../../md-docs/hydra" >hydra</a></li></ul><ul><li><a href="../../md-docs/dmt" >dmt</a></li></ul><ul><li><a href="../../md-docs/tmo" >tmo</a></li></ul><ul><li><a href="../../md-docs/raminate" >raminate</a></li></ul><ul><li><a href="../../md-docs/HeteroOS" >HeteroOS</a></li></ul><ul><li><a href="../../md-docs/hotbox" >hotbox</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/tpp","../../md-docs/hugescope","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>