<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/shell.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/os-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">hugescope</a><ul><li><a href="#h2-1">研究问题</a></li></ul><ul><li><a href="#h2-2">局限性分析</a></li></ul><ul><li><a href="#h2-3">解决方案</a><ul><li><a href="#h3-4">内存访问追踪</a></li></ul></li></ul><ul><li><a href="#h2-5">实验</a><ul><li><a href="#h3-6">实验结果</a></li></ul><ul><li><a href="#h3-7">证明有效性</a></li></ul></li></ul><ul><li><a href="#h2-8">个人思考</a></li></ul><ul><li><a href="#h2-9">摘抄</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">hugescope</h1><ul><li>题目: Taming Hot Bloat Under Virtualization with HugeScope</li></ul><ul><li>会议: USENIX ACT&#x27;24</li></ul><ul><li>视频: <a href="https://www.youtube.com/watch?v=30Y5-sBz1Wo" target="_blank">USENIX ATC &#x27;24 - Taming Hot Bloat Under Virtualization with HUGESCOPE</a></li></ul><ul><li>代码: <a href="https://github.com/TELOS-syslab/hugescope-atc24-ae" target="_blank">hugescope-atc24-ae</a></li></ul><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><p><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div> 本文作者和 <a href="../../md-docs\vtmm" target="_self">vTMM</a> 的作者是一个组的</p><p>本文主要是针对虚拟化大页访问偏度的优化, 和分层内存管理关系不大</p></blockquote><h2 id="h2-1">研究问题</h2><blockquote><p>论文试图解决的具体问题是什么?该问题的核心挑战是什么?</p></blockquote><p>随着虚拟机(VM)内存占用的增加,大页面被用来减轻TLB的压力.这带来了显着的性能提升(在各种基准测试中提升了11%-53%),原因有两个:(1)它增加了TLB覆盖范围,降低了TLB丢失率;(2)减少了页面遍历的开销.</p><p>研究发现对于许多工作负载来说,在其执行期间,对大页的基页(即4KB页)的访问是高度倾斜的;一些基页被频繁访问,而另一些基页则很少被访问或根本不被访问. 而本文试图解决这种虚拟化环境下使用大页(huge pages)导致的&quot;<b>热膨胀</b>&quot;(hot bloat)问题. 即由于对少数基本页面的访问存在偏差,系统会错误地将整个大页面分类为热门页面.</p><blockquote><p>PRISM 包括迄今为止对这一现象最广泛的研究.对于一组 35 个基准测试,包括一整套 PARSEC、SPEC、三个 GPU 基准测试和多个服务器基准测试,69% 的基准表现出这种访问偏度.</p></blockquote><p>当访问集中于大页中的少数基本页(如 4KB 页)时,虚拟机管理程序会错误地将整个大页标记为&quot;热&quot;,从而导致虚拟化中的多项关键技术(如分层内存管理和页共享)效率下降. 之前解决热膨胀的工作要么需要硬件修改,要么针对特定场景,并且不适用于虚拟机管理程序.本文提出的 HugeScope,是一个轻量级、有效且通用的系统,它解决了基于商用硬件的虚拟化下的热膨胀问题.</p><h2 id="h2-2">局限性分析</h2><blockquote><p>现有研究的主要局限或缺点是什么?</p></blockquote><p>现有研究在应对虚拟化环境中的&quot;热膨胀&quot;问题时存在几个主要局限或缺点:</p><ol start="1"><li><b>需要硬件修改</b>:一些解决方案(如 PRISM 和 RainBow)依赖于硬件更改,限制了它们在现有商用硬件上的适用性,增加了部署成本和复杂性.</li></ol><ol start="2"><li><b>针对特定场景设计</b>:许多现有方法只能在特定场景下有效.例如,Memtis 使用处理器事件采样(PEBS)跟踪内存访问,但这种方法无法应用于通用虚拟化环境,尤其是因为硬件限制使得管理程序无法可靠地监控来宾虚拟机的内存访问.</li></ol><ol start="3"><li><b>监控精度问题</b>:一些方法,如 Thermostat,采用采样技术来跟踪内存访问,这种采样方法往往不够精确,导致系统在进行内存管理决策时出现次优表现.</li></ol><ol start="4"><li><b>高开销</b>:传统方法(如使用页故障或分裂大页的机制)会带来显著的性能开销,尤其是在虚拟化环境中,频繁的页表修改可能导致大量的虚拟机退出,从而严重影响系统性能.</li></ol><h2 id="h2-3">解决方案</h2><blockquote><p>动机</p></blockquote><p>直观上,为了获得大页内的访问偏度,可以<b>将大页拆分为基页</b>,并使用基于分页的机制跟踪对这些基页的内存访问.访问跟踪期结束后,基页可以合并回大页,以继续享受大页的性能优势</p><p>但是,<b>执行拆分和合并的开销是不可接受的</b>. 这两个操作都需要使虚拟机的 EPT 无效.当再次访问这些页面时(对于这些活动页面来说,在不久的将来),这会导致昂贵的 VM 退出来重建 EPT</p><blockquote><p>对比评估了 split_huge_page() 和 collapse_huge_page() 两个函数的开销 145ns 和 250ns</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20241110232341.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20241110232341.png" alt="20241110232341"></a></p><p>因此必须在很高的页面拆分/合并开销的情况下实现轻量级、精确的基页粒度内存访问跟踪</p><p>本文的动机来自于两个观察发现</p><ol start="1"><li>EPT 很少修改.在构建扩展页表项(EPTE)之后,管理程序很少对其进行修改.这是因为来宾页表 (GPT) 吸收了来自应用程序的所有页表修改请求(例如,映射和取消映射页面、更改权限位). EPT的访问只会出现在hypervisor管理请求中.<p>下图可知绝大部分页表的修改都发生在 GPT 中</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20241110232116.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20241110232116.png" alt="20241110232116"></a></p></li></ol><ol start="2"><li>即使虚拟机管理程序访问/修改 EPT,它也总是通过一些稳定的接口来实现.<ul><li>它们通过少量函数(例如 KVM 中的 11 个)访问/修改 EPT.</li></ul><ul><li>这套接口稳定.对于 KVM 和 Xen,在过去 9 年和 7 年中分别没有向该集合添加或删除任何功能.</li></ul></li></ol><hr><p>Hugescope 的设计如下, 主要分为三个部分</p><ol start="1"><li>页面访问追踪</li></ol><ol start="2"><li>轻量级页表拆分和合并来获取热大页的访问倾斜度</li></ol><ol start="3"><li>考虑页面热度和偏斜度的默认页面大小策略来解决热膨胀问题</li></ol><blockquote><p>以及模块化的接口</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20241111003336.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20241111003336.png" alt="20241111003336"></a></p><h3 id="h3-4">内存访问追踪</h3><p>跟踪内存访问的最直接方法是通过页面错误. 即通过设置内存页面的权限位(如将一个页面标记为只读或不可访问),当程序试图进行相应的内存操作时,会产生一个页面错误.操作系统或监控程序可以捕获这个页面错误,记录访问行为,并选择是否恢复页面的原始权限,继续程序执行或进行其他处理. 但是这种方式处理页面错误的成本很高(并且在虚拟化环境中变得更加昂贵),因此基于页面错误的方法仅限于跟踪内存访问的小样本</p><blockquote><p><a href="../../md-docs\telescope" target="_self">telescope</a> 中比较详细的对比了几种页面追踪的方式, 除了页面错误还有页表扫描, 区间采样和硬件计数</p></blockquote><p>现代硬件在每个页表条目中包含一个访问/脏(A/D)位,以方便内存访问跟踪.不幸的是,这种方法无法跟踪对大页内基页的访问,因此无法获取访问倾斜度信息.处理器基于事件的采样.</p><blockquote style="border-left-color: #8250df; background-color: #eee4ff;"><p><div style="color: #8250df;"><img class="icon-important" loading="lazy" src="../../../img/important.svg" alt="[!IMPORTANT]"> IMPORTANT </div> 最近的系统使用名为处理器基于事件的采样(PEBS)的硬件功能来跟踪内存访问.</p><p>PEBS将触发条件(例如,每1000个LLC未命中)和PEBS缓冲区作为输入,由存储在名为IA32DSAREA的模型特定寄存器中的虚拟地址指定.每当触发条件满足时,PEBS就查阅 IA32_DS_AREA 来获取PEBS缓冲区的虚拟地址,并将进程ID和访问的虚拟地址写入PEBS缓冲区.</p><p>不幸的是,使用当前的硬件,虚拟机管理程序不可能使用PEBS监视来宾.这一限制是因为每个CPU只有一个 IA32_DS_AREA 寄存器,该寄存器由VM和虚拟机管理程序共享.当VM执行触发指定条件时,硬件记录到VM的虚拟地址(IA32_DS_AREA 中存储的地址)而不是hypervisorfis地址空间.这可能会损坏虚拟机(因为虚拟机不希望进行此类写入),并使虚拟机管理程序难以访问结果,因为它们驻留在虚拟机的地址空间中</p></blockquote><p>因此作者提出了<b>两阶段内存访问跟踪</b>:</p><ul><li><b>粗略阶段</b>:HugeScope 使用 EPT 中的访问和脏位(A/D bits)来跟踪所有页的访问频率和最近访问时间,而无需进行昂贵的页表分裂操作.这个阶段的目标是识别哪些大页是&quot;热&quot;的.</li></ul><ul><li><b>精细阶段</b>:在识别出热大页后,HugeScope 仅分裂这些大页,跟踪其每个基本页的访问情况,以获取更详细的访问模式(如访问倾斜性).在这一阶段结束后,系统将这些基本页重新合并为大页,以继续利用大页带来的性能优势.</li></ul><p>由于对管理程序元数据的修改成本高昂,当前页面拆分/合并所产生的开销是不可接受的.为了克服这一挑战,在细路径阶段,<b>HugeScope仅修改内存访问跟踪下的大页的EPT(具体而言,最后一级页表中的条目)以执行拆分和合并操作,而不执行任何修改到元数据结构</b>.</p><p>这种方法会导致 EPT 和虚拟机管理程序元数据之间<b>暂时不一致</b>; 当HugeScope拆分页表时(在精细路径阶段的开始),不一致会发生;当HugeScope合并页表时(在精细路径页面的末尾),不一致就会消失.这种方法很有效,因为管理程序很少访问和修改 EPT(第 3.3.2 节).因此,在大多数情况下,虚拟机管理程序永远不会观察到这种不一致(因为它不访问或修改 EPT).因此,在几乎所有情况下,HugeScope不需要采用特殊的回退机制来解决不一致问题</p><h2 id="h2-5">实验</h2><blockquote><p>实验是如何设计的? 结果如何证明了论文方法的有效性?是否有对比实验?</p></blockquote><p>本文的实验通过对 HugeScope 的性能、内存跟踪效率、以及与现有方法的对比来验证其有效性.实验设计包括以下几个方面:</p><ol start="1"><li><b>内存访问跟踪效率</b>:<ul><li>比较 HugeScope 的两阶段内存访问跟踪机制与现有方法(如基于页分裂的扫描、采样扫描和 PEBS(处理器事件采样))的开销与精确度.实验设置了不同的内存工作集规模,监测 Redis 等应用的内存访问情况,并分析跟踪的开销和准确度.</li></ul></li></ol><ol start="2"><li><b>页分裂与合并的性能影响</b>:<ul><li>通过运行顺序读取和写入微基准测试,评估 HugeScope 的虚拟化友好型页分裂和合并机制与传统 Linux 页表操作的性能开销.实验中测量了因页表修改引发的 VM 退出次数和整体性能下降情况.</li></ul></li></ol><ol start="3"><li><b>与现有方案的对比</b>:<ul><li>在分层内存管理(HS-TMM)和页共享(HS-Share)场景下,HugeScope 与现有系统(如 vTMM-Huge、vTMM-Base、Ingens 和 Linux KSM)进行了对比.实验使用不同的内存配置和工作负载(如 Redis、MongoDB、Graph500 等),测量各方法的性能提升、内存节省效果和平均延迟.</li></ul></li></ol><h3 id="h3-6">实验结果</h3><ol start="1"><li><b>内存访问跟踪效率</b>:<ul><li>HugeScope 在跟踪内存访问时,比基于页分裂的扫描显著降低了性能开销,平均仅为 3.04%,而页分裂扫描可达 25% 的性能损失.相比于采样扫描和 PEBS,HugeScope 提供了更高的精确度,并能够快速识别访问倾斜.</li></ul></li></ol><ol start="2"><li><b>页分裂与合并的性能影响</b>:<ul><li>HugeScope 的页分裂与合并机制显著减少了 VM 退出次数和性能损失.在工作集规模为 16GB 时,传统 Linux 分裂/合并操作导致性能下降高达 25.39%,而 HugeScope 的优化机制将其减少至 1.5%.</li></ul></li></ol><ol start="3"><li><b>对比实验</b>:<ul><li><b>分层内存管理(HS-TMM)</b>:HugeScope 支持的 HS-TMM 在高内存压力下显著优于 vTMM-Huge 和 vTMM-Base,性能提升最多达 61%.与传统的基于采样的 Thermostat 方法相比,HS-TMM 能更准确地跟踪热页并优化内存布局.</li></ul><ul><li><b>页共享系统(HS-Share)</b>:HS-Share 在内存节省和性能之间取得了良好的平衡,节省了 41% 的内存,同时仅有 3.6% 的性能损失,而 Ingens 由于热膨胀问题仅节省了 1.28% 的内存.</li></ul></li></ol><h3 id="h3-7">证明有效性</h3><p>通过对比实验结果可以看出,HugeScope 显著降低了内存访问跟踪的开销,提升了内存管理系统的性能,并有效解决了热膨胀问题.与现有方案相比,HugeScope 的改进在多种应用场景下表现出了优越性,证明了其方法的有效性和适用性.</p><h2 id="h2-8">个人思考</h2><blockquote><p>阅读论文时,有没有引发你思考出新的问题或有待解决的挑战?</p></blockquote><p>作者很详细的讨论的 PEBS 的原理以及为什么虚拟化中不能使用 PEBS, 可以作为论述的借鉴参考</p><p>依然使用的是 EPT 扫描的方式, 但是 <a href="../../md-docs\vtmm" target="_self">vTMM</a> 提到 EPT 的方式没有 GPT 高效</p><h2 id="h2-9">摘抄</h2></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/tpp" >tpp</a></li></ul><ul><li><a href="../../md-docs/vtmm" >vtmm</a></li></ul><ul><li><a href="../../md-docs/hugescope" >hugescope</a></li></ul><ul><li><a href="../../md-docs/memtis" >memtis</a></li></ul><ul><li><a href="../../md-docs/hugegpt" >hugegpt</a></li></ul><ul><li><a href="../../md-docs/hemem" >hemem</a></li></ul><ul><li><a href="../../md-docs/nimble" >nimble</a></li></ul><ul><li><a href="../../md-docs/mitosis" >mitosis</a></li></ul><ul><li><a href="../../md-docs/thermostat" >thermostat</a></li></ul><ul><li><a href="../../md-docs/telescope" >telescope</a></li></ul><ul><li><a href="../../md-docs/mtm" >mtm</a></li></ul><ul><li><a href="../../md-docs/nomad" >nomad</a></li></ul><ul><li><a href="../../md-docs/autotiering" >autotiering</a></li></ul><ul><li><a href="../../md-docs/hydra" >hydra</a></li></ul><ul><li><a href="../../md-docs/dmt" >dmt</a></li></ul><ul><li><a href="../../md-docs/tmo" >tmo</a></li></ul><ul><li><a href="../../md-docs/raminate" >raminate</a></li></ul><ul><li><a href="../../md-docs/HeteroOS" >HeteroOS</a></li></ul><ul><li><a href="../../md-docs/hotbox" >hotbox</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/vtmm","../../md-docs/memtis","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>