
# gem5

> 笔者注: 本篇文章比较简单,是对gem5背景,模块设计的一个概述,比较适合用在 "一段话介绍gem5是什么" 的场景, 同时这也是gem5的最初论文(2011),后面的gem5-simulator-version20是对于gem5后续更新变化的补充说明(2020)

gem5 模拟基础设施是 M5 和 GEMS 模拟器的最佳方面的合并. 

- M5 提供高度可配置的仿真框架/多个 ISA 和多样化的 CPU 模型. 
- GEMS 通过详细而灵活的内存系统补充了这些功能,包括支持多种缓存一致性协议和互连模型

目前,gem5 支持大多数商业 ISA(ARM/ALPHA/MIPS/Power/SPARC 和 x86),包括在其中三个(ARM/ALPHA 和 x86)上启动 Linux, 是许多学术和工业机构共同努力的结果

## 出现背景

计算机体系结构研究者需要软件去模拟和验证他们的想法

- 多核系统和更深缓存层次结构的出现为架构师提供了几个新的探索维度
- 研究人员**需要一个灵活的仿真框架**来评估各种设计并支持丰富的操作系统设施,包括 IO 和网络.
- 计算机体系结构研究人员还需要一个模拟框架,使他们能够与**工业界和学术界**的同事进行协作.但是,模拟器的许可条款和代码质量会阻碍这种协作.**一些开源软件许可证可能过于严格**,尤其是在工业环境中,因为它们需要发布任何模拟器增强功能.此外,糟**糕的代码质量和缺乏模块化会使新用户难以理解和修改代码**
- gem5 模拟器通过提供灵活的模块化模拟系统克服了这些限制,该系统能够评估范围广泛的系统,并且可供所有研究人员广泛使用.该基础架构通过提供一组不同的 CPU 模型/系统执行模式和内存系统模型来提供灵活性.对模块化和干净接口的承诺使研究人员可以专注于代码的特定方面,而无需了解整个代码库.基于 BSD 的许可证使所有研究人员都可以使用代码,而不受尴尬的法律限制.

gem5的三个目标:

- 对于用户: 灵活的建模
- 对于社区: 广泛的可用性和实用性
- 促进高水平的开发人员合作

## 设计特点

### 灵活性

gem5提供了四种CPU模型

- AtomicSimple 是最小的单一 IPC CPU 模型,非流水线 CPU 模型(在每个周期获取/解码/执行和提交单个指令)

  最小的单一 IPC CPU,可立即完成所有内存访问.这种低开销使 AtomicSimple 适合去模拟任务

- TimingSimple , 非流水线 CPU 模型

  CPU 对内存访问的时序进行了建模

- InOrder ,流水线/有序 CPU

  InOrder 模型是一种"execute-in-execute"CPU 模型(指令仅在所有依赖关系都已解决后才在执行阶段执行),强调指令时序和模拟,带有序管道
  
  可以配置为模拟不同数量的流水线阶段/问题宽度和硬件线程数

- O3 ,流水线/无序模型

  "execute-in-execute"CPU 模型, 它模拟指令/功能单元/内存访问和流水线阶段之间的依赖关系.加载/存储队列和重新排序缓冲区等可参数化管道资源允许 O3 模拟超标量架构和具有多个硬件线程 (SMT) 的 CPU.

模拟模式

- 系统调用仿真 (SE): 通过模拟大多数系统级服务,避免对设备或操作系统 (OS) 建模的需要
- 全系统 (FS) 模式: 执行用户级和内核级指令,并对包括操作系统和设备在内的完整系统建模

内存系统

- Classic 模型(来自 M5): 提供了一个快速且易于配置的内存系统
- Ruby 模型(来自 GEMS): 提供了一个灵活的基础设施,能够准确模拟各种缓存一致的内存系统

![20230219213819](https://raw.githubusercontent.com/learner-lu/picbed/master/20230219213819.png)

### Python + C++

为了灵活性和扩展性采用面向对象的设计,所有组件都源于SimObject对象,例如处理器内核/缓存/互连元素和设备,以及更抽象的实体,例如工作负载及其相关的系统调用仿真进程上下文

每个 SimObject 由两个类表示,一个在 Python 中,一个在 C++ 中,它们派生自每种语言中存在的 SimObject 基类. Python 类定义指定 SimObject 的参数并用于基于脚本的配置.通用的 Python 基类为实例化/命名和设置参数值提供了统一的机制. C++ 类包含 SimObject 的状态和剩余行为,包括性能关键型仿真模型

虽然大部分(85%)代码是由C++编写的,但可以使用python脚本快速创建可以执行的内容

### DSL

> DSL代表领域特定语言(Domain-Specific Language),是一种专门针对特定领域的编程语言.与通用编程语言(如Java/Python/C++等)相比,DSL是为解决某一特定问题而设计的语言,其语法和结构在该领域中非常有意义和相关.DSL的优点是更容易理解和使用,因为它们更贴近特定问题领域的术语和惯例.此外,DSL还可以提供更高的生产力,因为它们可以使开发人员更快地编写代码.DSL的种类很多,例如SQL是一种用于数据库查询的DSL,HTML是一种用于网页设计的DSL.DSL可以是内部的(只在某个组织或项目中使用),也可以是外部的(可以在多个项目或组织中使用)

gem5提供了两组DSL, ISA DSL和Cache Coherence DSL

## 标准接口

标准接口是面向对象设计的基础.两个中心接口是**端口接口**和**消息缓冲区接口**

端口是用于在 gem5 中将两个内存对象连接在一起的接口之一.在经典内存系统中,端口接口连接所有内存对象,包括 CPU 到缓存/缓存到总线/总线到设备和内存.端口支持三种访问数据的机制(时序/原子和功能)和一个用于确定拓扑和调试等事情的接口.

- 时序模式用于对内存访问的详细时序进行建模.通过发送消息向内存系统发出请求,并期望通过其他消息异步返回响应.
- 原子模式用于获取一些时间信息,但不是面向消息的.当进行原子调用时(通过函数调用),操作的状态更改是同步执行的.这具有更高的性能,但会放弃一些准确性,因为消息交互没有建模.
- 功能模式更新模拟器状态而不改变任何时序信息.这些通常用于调试/系统调用仿真和初始化

后面又聊了聊缓存一致性协议和网络拓扑,看不懂